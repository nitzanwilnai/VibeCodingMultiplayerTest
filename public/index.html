<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Dark Room — Multiplayer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    cursor: crosshair;
    font-family: 'Courier New', monospace;
  }
  canvas { display: block; }

  #overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    transition: opacity 1.5s ease;
  }
  #overlay.hidden { opacity: 0; pointer-events: none; }
  #overlay h1 {
    color: #8b0000;
    font-size: 3rem;
    letter-spacing: 0.5em;
    text-transform: uppercase;
    animation: flicker 3s infinite;
    margin-bottom: 1rem;
  }
  #overlay p { color: #555; font-size: 0.9rem; letter-spacing: 0.2em; }
  #overlay .name-row {
    margin-top: 1.5rem;
    display: flex; gap: 10px; align-items: center;
  }
  #overlay .name-row input {
    background: rgba(255,255,255,0.05);
    border: 1px solid #8b0000;
    color: #ccc;
    padding: 10px 16px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    letter-spacing: 0.1em;
    outline: none; width: 200px;
  }
  #overlay .name-row input:focus { border-color: #c0392b; }
  #overlay .start-btn {
    margin-top: 1.5rem;
    padding: 12px 40px;
    background: none;
    border: 1px solid #8b0000;
    color: #8b0000;
    font-family: 'Courier New', monospace;
    font-size: 1rem;
    letter-spacing: 0.3em;
    cursor: pointer;
    transition: all 0.3s;
  }
  #overlay .start-btn:hover { background: #8b0000; color: #000; }

  @keyframes flicker {
    0%, 100% { opacity: 1; }
    42% { opacity: 0.3; } 43% { opacity: 1; }
    78% { opacity: 0.6; } 79% { opacity: 1; }
  }

  #hud {
    position: fixed; top: 16px; right: 20px;
    color: #444; font-size: 0.7rem;
    letter-spacing: 0.15em; z-index: 5;
    pointer-events: none; text-align: right; line-height: 1.8;
  }
  #hud .online { color: #8b0000; }

  #connection-indicator {
    position: fixed; top: 16px; left: 20px;
    display: flex; align-items: center; gap: 8px;
    z-index: 5; pointer-events: none;
  }
  #connection-indicator .dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: #333; transition: all 0.3s;
  }
  #connection-indicator .dot.on { background: #4a1a1a; box-shadow: 0 0 6px #8b0000; }
  #connection-indicator .dot.off { background: #8b0000; animation: pulse-dot 1.5s infinite; }
  @keyframes pulse-dot { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
  #connection-indicator .label {
    color: #333; font-size: 0.6rem;
    letter-spacing: 0.15em; text-transform: uppercase;
  }

  #puzzle-hud {
    position: fixed; bottom: 20px; left: 50%;
    transform: translateX(-50%);
    display: flex; gap: 12px; align-items: center;
    z-index: 5; pointer-events: none;
  }
  .stone-indicator {
    width: 28px; height: 28px; border-radius: 4px;
    border: 1px solid #333; background: rgba(255,255,255,0.03);
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; color: #444;
    transition: all 0.4s ease;
  }
  .stone-indicator.active {
    border-color: #4a7; background: rgba(50, 180, 100, 0.15);
    color: #4a7; box-shadow: 0 0 10px rgba(50, 180, 100, 0.3);
  }
  .stone-indicator.reset-flash {
    border-color: #8b0000; background: rgba(139, 0, 0, 0.2);
    color: #8b0000;
  }

  #win-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 20;
  }
  #win-overlay.show { display: flex; }
  #win-overlay h2 {
    color: #4a7; font-size: 2rem;
    letter-spacing: 0.4em; text-transform: uppercase;
    animation: flicker 3s infinite;
  }
  #win-overlay p { color: #555; margin-top: 1rem; font-size: 0.9rem; letter-spacing: 0.2em; }
</style>
</head>
<body>

<div id="overlay">
  <h1>The Dark Room</h1>
  <p>WASD to move · Mouse to aim flashlight</p>
  <p style="margin-top: 0.5rem; color: #444;">Find the stones. Step on them in order.</p>
  <div class="name-row">
    <input type="text" id="nameInput" placeholder="Enter your name..." maxlength="20" />
  </div>
  <button class="start-btn" id="startBtn">ENTER THE DARK</button>
</div>

<canvas id="game"></canvas>

<div id="connection-indicator">
  <div class="dot" id="connDot"></div>
  <span class="label" id="connLabel">connecting</span>
</div>

<div id="hud">
  <span class="online" id="onlineCount">0</span> ONLINE
</div>

<div id="puzzle-hud">
  <div class="stone-indicator" id="si-1">1</div>
  <div class="stone-indicator" id="si-2">2</div>
  <div class="stone-indicator" id="si-3">3</div>
  <div class="stone-indicator" id="si-4">4</div>
  <div class="stone-indicator" id="si-5">5</div>
</div>

<div id="win-overlay">
  <h2>The Door Opens</h2>
  <p>You have escaped the dark room.</p>
</div>

<script>
// ═══════════════════════════════════════════════════════════
//  CONFIG
// ═══════════════════════════════════════════════════════════
const ROOM_SIZE = 800;
const WALL_THICKNESS = 16;
const PLAYER_RADIUS = 10;
const FLASHLIGHT_RANGE = 280;
const FLASHLIGHT_ANGLE = Math.PI / 5.5;
const LERP_FACTOR = 0.15;
const ANGLE_LERP = 0.12;
const SPEED = 2.2;
const STONE_SIZE = 32;

// ═══════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════
let myId = null;
let localPlayer = { x: 400, y: 400, angle: 0 };
let remotePlayers = {};
let keys = {};
let mouseX = 0, mouseY = 0;
let started = false;
let time = 0;
let ws = null;
let connected = false;

// Puzzle state (synced from server)
let puzzleProgress = 0;
let doorOpen = false;
let resetFlashTime = 0; // local time when reset happened

// Stone positions (sent from server on init, but we define defaults)
let stones = [
  { x: 300, y: 620, num: 1 },
  { x: 350, y: 540, num: 2 },
  { x: 400, y: 460, num: 3 },
  { x: 450, y: 380, num: 4 },
  { x: 500, y: 300, num: 5 },
];

const DOOR = { x: 400, y: 8, width: 60, height: 16 };

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ═══════════════════════════════════════════════════════════
//  ROOM OBJECTS
// ═══════════════════════════════════════════════════════════
const columns = [
  { x: 250, y: 250, r: 28 },
  { x: 550, y: 250, r: 28 },
  { x: 250, y: 550, r: 28 },
  { x: 550, y: 550, r: 28 },
];

const pedestal = { x: 400, y: 400, size: 36 };

const particles = [];
for (let i = 0; i < 80; i++) {
  particles.push({
    x: Math.random() * ROOM_SIZE,
    y: Math.random() * ROOM_SIZE,
    vx: (Math.random() - 0.5) * 0.3,
    vy: (Math.random() - 0.5) * 0.3,
    size: Math.random() * 2 + 0.5,
    alpha: Math.random() * 0.5 + 0.1,
  });
}

// ═══════════════════════════════════════════════════════════
//  PUZZLE HUD
// ═══════════════════════════════════════════════════════════
function updatePuzzleHUD(isReset) {
  for (let i = 1; i <= 5; i++) {
    const el = document.getElementById(`si-${i}`);
    el.classList.remove('active', 'reset-flash');
    if (i <= puzzleProgress) {
      el.classList.add('active');
    }
  }
  if (isReset) {
    // Brief red flash on all indicators
    for (let i = 1; i <= 5; i++) {
      const el = document.getElementById(`si-${i}`);
      el.classList.add('reset-flash');
    }
    setTimeout(() => {
      for (let i = 1; i <= 5; i++) {
        document.getElementById(`si-${i}`).classList.remove('reset-flash');
      }
    }, 600);
    resetFlashTime = time;
  }

  if (doorOpen) {
    setTimeout(() => {
      document.getElementById('win-overlay').classList.add('show');
    }, 1000);
  }
}

// ═══════════════════════════════════════════════════════════
//  WEBSOCKET
// ═══════════════════════════════════════════════════════════
function wsConnect() {
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  ws = new WebSocket(`${protocol}//${location.host}`);

  ws.onopen = () => {
    connected = true;
    document.getElementById('connDot').className = 'dot on';
    document.getElementById('connLabel').textContent = 'connected';
  };

  ws.onclose = () => {
    connected = false;
    myId = null;
    remotePlayers = {};
    document.getElementById('connDot').className = 'dot off';
    document.getElementById('connLabel').textContent = 'reconnecting';
    setTimeout(wsConnect, 2000);
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    switch (msg.type) {
      case "init": {
        myId = msg.id;
        const all = msg.players;
        if (all[myId]) {
          localPlayer.x = all[myId].x;
          localPlayer.y = all[myId].y;
          localPlayer.angle = all[myId].angle;
        }
        for (const [id, p] of Object.entries(all)) {
          if (Number(id) === myId) continue;
          remotePlayers[id] = {
            x: p.x, y: p.y, angle: p.angle,
            tx: p.x, ty: p.y, tAngle: p.angle,
            color: p.color, name: p.name,
          };
        }
        // Puzzle state from server
        if (msg.puzzle) {
          puzzleProgress = msg.puzzle.progress;
          doorOpen = msg.puzzle.doorOpen;
          if (msg.puzzle.stones) stones = msg.puzzle.stones;
          updatePuzzleHUD(false);
        }
        const nameVal = document.getElementById('nameInput').value.trim();
        if (nameVal && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "set_name", name: nameVal }));
        }
        updateOnlineCount();
        break;
      }
      case "player_joined": {
        const p = msg.player;
        remotePlayers[msg.id] = {
          x: p.x, y: p.y, angle: p.angle,
          tx: p.x, ty: p.y, tAngle: p.angle,
          color: p.color, name: p.name,
        };
        updateOnlineCount();
        break;
      }
      case "player_moved": {
        const rp = remotePlayers[msg.id];
        if (rp) { rp.tx = msg.x; rp.ty = msg.y; rp.tAngle = msg.angle; }
        break;
      }
      case "player_renamed": {
        const rp = remotePlayers[msg.id];
        if (rp) rp.name = msg.name;
        break;
      }
      case "player_left": {
        delete remotePlayers[msg.id];
        updateOnlineCount();
        break;
      }
      case "puzzle_update": {
        puzzleProgress = msg.progress;
        doorOpen = msg.doorOpen;
        updatePuzzleHUD(msg.reset);
        break;
      }
    }
  };
}
wsConnect();

function updateOnlineCount() {
  document.getElementById('onlineCount').textContent = Object.keys(remotePlayers).length + (myId ? 1 : 0);
}

// ═══════════════════════════════════════════════════════════
//  INPUT
// ═══════════════════════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  if (document.getElementById('overlay').classList.contains('hidden') || e.target.tagName !== 'INPUT') {
    keys[e.key.toLowerCase()] = true;
  }
});
document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
document.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });

canvas.addEventListener('click', () => {});

document.getElementById('startBtn').addEventListener('click', () => {
  started = true;
  document.getElementById('overlay').classList.add('hidden');
  const name = document.getElementById('nameInput').value.trim();
  if (name && ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "set_name", name }));
  }
  canvas.focus();
});

document.getElementById('nameInput').addEventListener('keydown', (e) => {
  e.stopPropagation();
  if (e.key === 'Enter') document.getElementById('startBtn').click();
});

// ═══════════════════════════════════════════════════════════
//  COLLISION
// ═══════════════════════════════════════════════════════════
function circleCollides(px, py, pr, cx, cy, cr) {
  const dx = px - cx, dy = py - cy;
  return Math.sqrt(dx * dx + dy * dy) < pr + cr;
}

function tryMove(nx, ny) {
  const margin = PLAYER_RADIUS + WALL_THICKNESS;
  nx = Math.max(margin, Math.min(ROOM_SIZE - margin, nx));
  ny = Math.max(margin, Math.min(ROOM_SIZE - margin, ny));

  for (const col of columns) {
    if (circleCollides(nx, ny, PLAYER_RADIUS, col.x, col.y, col.r)) {
      const dx = nx - col.x, dy = ny - col.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const push = (PLAYER_RADIUS + col.r) / dist;
      nx = col.x + dx * push;
      ny = col.y + dy * push;
    }
  }

  // Pedestal collision
  const ps = pedestal.size / 2 + PLAYER_RADIUS;
  if (nx > pedestal.x - ps && nx < pedestal.x + ps &&
      ny > pedestal.y - ps && ny < pedestal.y + ps) {
    const dx = nx - pedestal.x, dy = ny - pedestal.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      nx = pedestal.x + Math.sign(dx) * ps;
    } else {
      ny = pedestal.y + Math.sign(dy) * ps;
    }
  }

  // Door collision — block passage unless door is open
  if (!doorOpen) {
    const dLeft = DOOR.x - DOOR.width / 2;
    const dRight = DOOR.x + DOOR.width / 2;
    const dBottom = DOOR.y + DOOR.height;
    // Block if player is near the top wall door area
    if (ny - PLAYER_RADIUS < dBottom && nx > dLeft && nx < dRight) {
      ny = dBottom + PLAYER_RADIUS;
    }
  }

  localPlayer.x = nx;
  localPlayer.y = ny;
}

// ═══════════════════════════════════════════════════════════
//  FLASHLIGHT HELPERS
// ═══════════════════════════════════════════════════════════
function isInFlashlight(wx, wy, px, py, pAngle) {
  const dx = wx - px, dy = wy - py;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > FLASHLIGHT_RANGE) return 0;
  const angleToPoint = Math.atan2(dy, dx);
  let angleDiff = angleToPoint - pAngle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  if (Math.abs(angleDiff) > FLASHLIGHT_ANGLE) return 0;
  return (1 - dist / FLASHLIGHT_RANGE) * (1 - Math.abs(angleDiff) / FLASHLIGHT_ANGLE);
}

function castRay(ox, oy, angle, maxDist) {
  const step = 3;
  for (let d = 0; d < maxDist; d += step) {
    const x = ox + Math.cos(angle) * d;
    const y = oy + Math.sin(angle) * d;
    if (x <= WALL_THICKNESS || x >= ROOM_SIZE - WALL_THICKNESS ||
        y <= WALL_THICKNESS || y >= ROOM_SIZE - WALL_THICKNESS) {
      // Allow rays through the door opening if door is open
      if (doorOpen) {
        const dLeft = DOOR.x - DOOR.width / 2;
        const dRight = DOOR.x + DOOR.width / 2;
        if (y <= WALL_THICKNESS && x > dLeft && x < dRight) continue;
      }
      return d;
    }
    for (const col of columns) {
      const cdx = x - col.x, cdy = y - col.y;
      if (cdx * cdx + cdy * cdy < col.r * col.r) return d;
    }
    const hs = pedestal.size / 2;
    if (x > pedestal.x - hs && x < pedestal.x + hs &&
        y > pedestal.y - hs && y < pedestal.y + hs) return d;
  }
  return maxDist;
}

function buildLightPoly(px, py, pAngle) {
  const numRays = 80;
  const startA = pAngle - FLASHLIGHT_ANGLE;
  const endA = pAngle + FLASHLIGHT_ANGLE;
  const step = (endA - startA) / numRays;
  const poly = [{ x: px, y: py }];
  for (let i = 0; i <= numRays; i++) {
    const a = startA + step * i;
    const dist = castRay(px, py, a, FLASHLIGHT_RANGE);
    poly.push({ x: px + Math.cos(a) * dist, y: py + Math.sin(a) * dist });
  }
  return poly;
}

// Get total light at a world position from all flashlights
function getTotalLight(wx, wy) {
  let total = isInFlashlight(wx, wy, localPlayer.x, localPlayer.y, localPlayer.angle);
  for (const rp of Object.values(remotePlayers)) {
    total = Math.max(total, isInFlashlight(wx, wy, rp.x, rp.y, rp.angle));
  }
  return total;
}

// ═══════════════════════════════════════════════════════════
//  UPDATE
// ═══════════════════════════════════════════════════════════
let lastSentX = 0, lastSentY = 0, lastSentAngle = 0;

function update() {
  if (!started) return;
  time += 0.016;

  const cos = Math.cos(localPlayer.angle);
  const sin = Math.sin(localPlayer.angle);
  let dx = 0, dy = 0;
  if (keys['w']) { dx += cos * SPEED; dy += sin * SPEED; }
  if (keys['s']) { dx -= cos * SPEED; dy -= sin * SPEED; }
  if (keys['a']) { dx += sin * SPEED; dy -= cos * SPEED; }
  if (keys['d']) { dx -= sin * SPEED; dy += cos * SPEED; }
  if (dx !== 0 || dy !== 0) tryMove(localPlayer.x + dx, localPlayer.y + dy);

  {
    const cx = canvas.width / 2, cy = canvas.height / 2;
    localPlayer.angle = Math.atan2(mouseY - cy, mouseX - cx);
  }

  if (ws && ws.readyState === WebSocket.OPEN) {
    const moved = Math.abs(localPlayer.x - lastSentX) > 0.5 ||
                  Math.abs(localPlayer.y - lastSentY) > 0.5 ||
                  Math.abs(localPlayer.angle - lastSentAngle) > 0.02;
    if (moved) {
      ws.send(JSON.stringify({ type: "move", x: localPlayer.x, y: localPlayer.y, angle: localPlayer.angle }));
      lastSentX = localPlayer.x;
      lastSentY = localPlayer.y;
      lastSentAngle = localPlayer.angle;
    }
  }

  for (const rp of Object.values(remotePlayers)) {
    rp.x += (rp.tx - rp.x) * LERP_FACTOR;
    rp.y += (rp.ty - rp.y) * LERP_FACTOR;
    let da = rp.tAngle - rp.angle;
    while (da > Math.PI) da -= Math.PI * 2;
    while (da < -Math.PI) da += Math.PI * 2;
    rp.angle += da * ANGLE_LERP;
  }

  for (const p of particles) {
    p.x += p.vx; p.y += p.vy;
    if (p.x < 0) p.x = ROOM_SIZE; if (p.x > ROOM_SIZE) p.x = 0;
    if (p.y < 0) p.y = ROOM_SIZE; if (p.y > ROOM_SIZE) p.y = 0;
  }
}

// ═══════════════════════════════════════════════════════════
//  DRAW
// ═══════════════════════════════════════════════════════════
function drawFlashlightPass(px, py, pAngle, tintColor, intensity) {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const offsetX = cx - localPlayer.x;
  const offsetY = cy - localPlayer.y;
  const lightPoly = buildLightPoly(px, py, pAngle);
  const flicker = 0.95 + Math.sin(time * 8 + px) * 0.03 + Math.sin(time * 13 + py) * 0.02;

  ctx.save();
  ctx.translate(offsetX, offsetY);

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(lightPoly[0].x, lightPoly[0].y);
  for (let i = 1; i < lightPoly.length; i++) ctx.lineTo(lightPoly[i].x, lightPoly[i].y);
  ctx.closePath();
  ctx.clip();

  const grad = ctx.createRadialGradient(px, py, 0, px, py, FLASHLIGHT_RANGE);
  if (tintColor) {
    const r = parseInt(tintColor.slice(1,3),16);
    const g = parseInt(tintColor.slice(3,5),16);
    const b = parseInt(tintColor.slice(5,7),16);
    grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.25 * flicker * intensity})`);
    grad.addColorStop(0.3, `rgba(${Math.floor(r*0.8)}, ${Math.floor(g*0.8)}, ${Math.floor(b*0.7)}, ${0.15 * flicker * intensity})`);
    grad.addColorStop(0.7, `rgba(${Math.floor(r*0.5)}, ${Math.floor(g*0.5)}, ${Math.floor(b*0.4)}, ${0.05 * flicker * intensity})`);
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  } else {
    grad.addColorStop(0, `rgba(255, 240, 200, ${0.35 * flicker})`);
    grad.addColorStop(0.3, `rgba(255, 220, 160, ${0.2 * flicker})`);
    grad.addColorStop(0.7, `rgba(200, 170, 120, ${0.08 * flicker})`);
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, ROOM_SIZE, ROOM_SIZE);

  // Floor tiles
  ctx.strokeStyle = 'rgba(80, 70, 55, 0.15)';
  ctx.lineWidth = 0.5;
  const tileSize = 40;
  for (let tx = 0; tx < ROOM_SIZE; tx += tileSize) {
    for (let ty = 0; ty < ROOM_SIZE; ty += tileSize) {
      const li = isInFlashlight(tx + tileSize/2, ty + tileSize/2, px, py, pAngle);
      if (li > 0.01) {
        ctx.globalAlpha = li * 0.6 * intensity;
        ctx.strokeRect(tx, ty, tileSize, tileSize);
      }
    }
  }
  ctx.globalAlpha = 1;

  // Walls
  ctx.fillStyle = '#3a3028';
  // Top wall — with door gap
  const dLeft = DOOR.x - DOOR.width / 2;
  const dRight = DOOR.x + DOOR.width / 2;
  ctx.fillRect(0, 0, dLeft, WALL_THICKNESS);
  ctx.fillRect(dRight, 0, ROOM_SIZE - dRight, WALL_THICKNESS);
  // Bottom, left, right walls
  ctx.fillRect(0, ROOM_SIZE - WALL_THICKNESS, ROOM_SIZE, WALL_THICKNESS);
  ctx.fillRect(0, 0, WALL_THICKNESS, ROOM_SIZE);
  ctx.fillRect(ROOM_SIZE - WALL_THICKNESS, 0, WALL_THICKNESS, ROOM_SIZE);

  // Door frame
  if (!doorOpen) {
    // Closed door — heavy wooden look
    const doorLi = isInFlashlight(DOOR.x, DOOR.y + DOOR.height/2, px, py, pAngle);
    if (doorLi > 0.01) {
      ctx.fillStyle = `rgba(60, 40, 25, ${doorLi})`;
      ctx.fillRect(dLeft, 0, DOOR.width, WALL_THICKNESS);
      // Iron bands
      ctx.fillStyle = `rgba(100, 90, 70, ${doorLi * 0.6})`;
      ctx.fillRect(dLeft + 4, 4, DOOR.width - 8, 2);
      ctx.fillRect(dLeft + 4, WALL_THICKNESS - 6, DOOR.width - 8, 2);
      // Lock symbol
      ctx.fillStyle = `rgba(180, 50, 50, ${doorLi * 0.8})`;
      ctx.beginPath();
      ctx.arc(DOOR.x, WALL_THICKNESS / 2, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  } else {
    // Open door — gap in wall, green glow
    const doorLi = isInFlashlight(DOOR.x, DOOR.y + DOOR.height/2, px, py, pAngle);
    if (doorLi > 0.005) {
      const escapeGlow = ctx.createRadialGradient(DOOR.x, 0, 0, DOOR.x, 0, 80);
      escapeGlow.addColorStop(0, `rgba(50, 180, 100, ${0.3 * doorLi})`);
      escapeGlow.addColorStop(1, 'rgba(50, 180, 100, 0)');
      ctx.fillStyle = escapeGlow;
      ctx.fillRect(DOOR.x - 80, -20, 160, 100);
    }
  }

  ctx.strokeStyle = 'rgba(100, 85, 65, 0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(WALL_THICKNESS, WALL_THICKNESS, ROOM_SIZE - WALL_THICKNESS*2, ROOM_SIZE - WALL_THICKNESS*2);

  // Columns
  for (const col of columns) {
    const ci = isInFlashlight(col.x, col.y, px, py, pAngle);
    if (ci > 0.01) {
      ctx.fillStyle = `rgba(20, 15, 10, ${ci * 0.5})`;
      ctx.beginPath();
      ctx.ellipse(col.x + 3, col.y + 3, col.r + 4, col.r + 4, 0, 0, Math.PI * 2);
      ctx.fill();
      const cGrad = ctx.createRadialGradient(col.x - col.r*0.3, col.y - col.r*0.3, 0, col.x, col.y, col.r);
      cGrad.addColorStop(0, `rgba(120, 105, 85, ${ci})`);
      cGrad.addColorStop(0.6, `rgba(80, 70, 55, ${ci})`);
      cGrad.addColorStop(1, `rgba(40, 35, 28, ${ci})`);
      ctx.fillStyle = cGrad;
      ctx.beginPath();
      ctx.arc(col.x, col.y, col.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = `rgba(150, 130, 100, ${ci * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(col.x, col.y, col.r, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Pedestal
  const pedI = isInFlashlight(pedestal.x, pedestal.y, px, py, pAngle);
  if (pedI > 0.01) {
    const hs = pedestal.size / 2;
    ctx.fillStyle = `rgba(20, 15, 10, ${pedI * 0.4})`;
    ctx.fillRect(pedestal.x - hs + 3, pedestal.y - hs + 3, pedestal.size, pedestal.size);
    const pGrad = ctx.createLinearGradient(pedestal.x - hs, pedestal.y - hs, pedestal.x + hs, pedestal.y + hs);
    pGrad.addColorStop(0, `rgba(100, 85, 70, ${pedI})`);
    pGrad.addColorStop(0.5, `rgba(70, 60, 48, ${pedI})`);
    pGrad.addColorStop(1, `rgba(50, 42, 35, ${pedI})`);
    ctx.fillStyle = pGrad;
    ctx.fillRect(pedestal.x - hs, pedestal.y - hs, pedestal.size, pedestal.size);
    ctx.strokeStyle = `rgba(180, 150, 100, ${pedI * 0.5})`;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(pedestal.x - hs + 4, pedestal.y - hs + 4, pedestal.size - 8, pedestal.size - 8);
    const glowPulse = 0.3 + Math.sin(time * 2) * 0.15;
    const glowGrad = ctx.createRadialGradient(pedestal.x, pedestal.y, 0, pedestal.x, pedestal.y, hs * 1.5);
    glowGrad.addColorStop(0, `rgba(180, 50, 50, ${glowPulse * pedI})`);
    glowGrad.addColorStop(1, 'rgba(180, 50, 50, 0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(pedestal.x - hs*2, pedestal.y - hs*2, pedestal.size*2, pedestal.size*2);
  }

  // ── STONE SLABS ──
  for (const stone of stones) {
    const si = isInFlashlight(stone.x, stone.y, px, py, pAngle);
    if (si > 0.01) {
      const isActive = stone.num <= puzzleProgress;
      const hs = STONE_SIZE / 2;
      const isResetFlashing = (time - resetFlashTime) < 0.5;

      // Shadow
      ctx.fillStyle = `rgba(10, 8, 5, ${si * 0.5})`;
      ctx.beginPath();
      ctx.ellipse(stone.x + 2, stone.y + 2, hs + 2, hs * 0.6 + 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Stone slab (rounded rectangle via ellipse)
      if (isActive) {
        // Activated — green glow
        const gGrad = ctx.createRadialGradient(stone.x, stone.y, 0, stone.x, stone.y, hs * 1.8);
        gGrad.addColorStop(0, `rgba(50, 180, 100, ${0.25 * si})`);
        gGrad.addColorStop(1, 'rgba(50, 180, 100, 0)');
        ctx.fillStyle = gGrad;
        ctx.beginPath();
        ctx.ellipse(stone.x, stone.y, hs * 1.8, hs * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(40, 120, 70, ${si})`;
      } else if (isResetFlashing) {
        // Red flash on reset
        ctx.fillStyle = `rgba(139, 0, 0, ${si * 0.8})`;
      } else {
        // Inactive stone
        ctx.fillStyle = `rgba(70, 60, 50, ${si})`;
      }

      // Draw stone shape
      ctx.beginPath();
      ctx.ellipse(stone.x, stone.y, hs, hs * 0.65, 0, 0, Math.PI * 2);
      ctx.fill();

      // Stone border
      ctx.strokeStyle = isActive
        ? `rgba(80, 200, 120, ${si * 0.6})`
        : `rgba(100, 85, 65, ${si * 0.4})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(stone.x, stone.y, hs, hs * 0.65, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Number engraving
      ctx.fillStyle = isActive
        ? `rgba(180, 255, 200, ${si * 0.9})`
        : `rgba(150, 130, 100, ${si * 0.7})`;
      ctx.font = `bold 16px "Courier New", monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(stone.num), stone.x, stone.y);
    }
  }

  // Dust particles
  for (const p of particles) {
    const pi = isInFlashlight(p.x, p.y, px, py, pAngle);
    if (pi > 0.05) {
      ctx.fillStyle = `rgba(255, 240, 200, ${pi * p.alpha * 0.6 * intensity})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore(); // end clip
  ctx.restore(); // end world transform
}

function drawShadows(px, py, pAngle) {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const offsetX = cx - localPlayer.x;
  const offsetY = cy - localPlayer.y;

  ctx.save();
  ctx.translate(offsetX, offsetY);
  for (const col of columns) {
    const dx = col.x - px, dy = col.y - py;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < FLASHLIGHT_RANGE && isInFlashlight(col.x, col.y, px, py, pAngle) > 0) {
      const angle = Math.atan2(dy, dx);
      const perpAngle = angle + Math.PI / 2;
      const shadowLen = Math.min(200, FLASHLIGHT_RANGE - dist + 50);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
      ctx.beginPath();
      ctx.moveTo(col.x + Math.cos(perpAngle) * col.r, col.y + Math.sin(perpAngle) * col.r);
      ctx.lineTo(col.x - Math.cos(perpAngle) * col.r, col.y - Math.sin(perpAngle) * col.r);
      ctx.lineTo(col.x - Math.cos(perpAngle) * (col.r+10) + Math.cos(angle) * shadowLen,
                 col.y - Math.sin(perpAngle) * (col.r+10) + Math.sin(angle) * shadowLen);
      ctx.lineTo(col.x + Math.cos(perpAngle) * (col.r+10) + Math.cos(angle) * shadowLen,
                 col.y + Math.sin(perpAngle) * (col.r+10) + Math.sin(angle) * shadowLen);
      ctx.closePath();
      ctx.fill();
    }
  }
  ctx.restore();
}

function drawCharacter(px, py, pAngle, color, name, isLocal) {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const screenX = cx + (px - localPlayer.x);
  const screenY = cy + (py - localPlayer.y);

  let totalLight = isInFlashlight(px, py, localPlayer.x, localPlayer.y, localPlayer.angle);
  for (const rp of Object.values(remotePlayers)) {
    totalLight = Math.max(totalLight, isInFlashlight(px, py, rp.x, rp.y, rp.angle));
  }
  if (isLocal) totalLight = Math.max(totalLight, 0.3);
  if (totalLight < 0.02) return;

  const flicker = 0.95 + Math.sin(time * 8 + px) * 0.03;

  ctx.save();
  ctx.translate(screenX, screenY);
  ctx.rotate(pAngle + Math.PI / 2);
  ctx.globalAlpha = Math.min(1, totalLight + 0.1);

  const playerGlow = ctx.createRadialGradient(0, 0, 4, 0, 0, 28);
  playerGlow.addColorStop(0, 'rgba(180, 160, 130, 0.15)');
  playerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = playerGlow;
  ctx.beginPath();
  ctx.arc(0, 0, 28, 0, Math.PI * 2);
  ctx.fill();

  const bodyGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, PLAYER_RADIUS);
  if (isLocal) {
    bodyGrad.addColorStop(0, '#8a7b6b');
    bodyGrad.addColorStop(0.7, '#5c5045');
    bodyGrad.addColorStop(1, '#3a332c');
  } else {
    const r = parseInt(color.slice(1,3),16);
    const g = parseInt(color.slice(3,5),16);
    const b = parseInt(color.slice(5,7),16);
    bodyGrad.addColorStop(0, `rgb(${Math.floor(r*0.7)}, ${Math.floor(g*0.7)}, ${Math.floor(b*0.7)})`);
    bodyGrad.addColorStop(0.7, `rgb(${Math.floor(r*0.4)}, ${Math.floor(g*0.4)}, ${Math.floor(b*0.4)})`);
    bodyGrad.addColorStop(1, `rgb(${Math.floor(r*0.2)}, ${Math.floor(g*0.2)}, ${Math.floor(b*0.2)})`);
  }
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = isLocal ? 'rgba(200, 185, 155, 0.4)' : `${color}66`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
  ctx.stroke();

  const headGrad = ctx.createRadialGradient(-1, -PLAYER_RADIUS-3, 0, 0, -PLAYER_RADIUS-3, 6);
  headGrad.addColorStop(0, '#c4a882');
  headGrad.addColorStop(1, '#7a6a58');
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(0, -PLAYER_RADIUS - 3, 6, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#e8dcc8';
  ctx.beginPath();
  ctx.arc(-2.2, -PLAYER_RADIUS - 5, 1.2, 0, Math.PI * 2);
  ctx.arc(2.2, -PLAYER_RADIUS - 5, 1.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#555';
  ctx.fillRect(5, -PLAYER_RADIUS - 8, 3, 8);
  const lensGlow = ctx.createRadialGradient(6.5, -PLAYER_RADIUS-9, 0, 6.5, -PLAYER_RADIUS-9, 5);
  const lensColor = isLocal ? `rgba(255, 240, 180, ${0.8 * flicker})` : `${color}cc`;
  lensGlow.addColorStop(0, lensColor);
  lensGlow.addColorStop(0.5, isLocal ? `rgba(255, 220, 140, ${0.3 * flicker})` : `${color}44`);
  lensGlow.addColorStop(1, 'rgba(255, 240, 180, 0)');
  ctx.fillStyle = lensGlow;
  ctx.beginPath();
  ctx.arc(6.5, -PLAYER_RADIUS - 9, 5, 0, Math.PI * 2);
  ctx.fill();

  ctx.globalAlpha = 1;
  ctx.restore();

  if (name && totalLight > 0.1) {
    ctx.save();
    ctx.globalAlpha = Math.min(0.8, totalLight);
    ctx.fillStyle = isLocal ? '#aaa' : color;
    ctx.font = '10px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(name, screenX, screenY - PLAYER_RADIUS - 14);
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (!started) {
    requestAnimationFrame(draw);
    return;
  }

  ctx.globalCompositeOperation = 'lighter';
  drawFlashlightPass(localPlayer.x, localPlayer.y, localPlayer.angle, null, 1);
  for (const rp of Object.values(remotePlayers)) {
    drawFlashlightPass(rp.x, rp.y, rp.angle, rp.color, 0.85);
  }
  ctx.globalCompositeOperation = 'source-over';

  drawShadows(localPlayer.x, localPlayer.y, localPlayer.angle);
  for (const rp of Object.values(remotePlayers)) {
    drawShadows(rp.x, rp.y, rp.angle);
  }

  for (const rp of Object.values(remotePlayers)) {
    drawCharacter(rp.x, rp.y, rp.angle, rp.color, rp.name, false);
  }
  drawCharacter(localPlayer.x, localPlayer.y, localPlayer.angle, '#8a7b6b', 'You', true);

  // Post-processing
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const vigGrad = ctx.createRadialGradient(cx, cy, canvas.width * 0.2, cx, cy, canvas.width * 0.7);
  vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
  for (let y = 0; y < canvas.height; y += 3) {
    ctx.fillRect(0, y, canvas.width, 1);
  }

  if (!connected) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#8b0000';
    ctx.font = 'bold 16px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('CONNECTION LOST — RECONNECTING...', canvas.width/2, canvas.height/2);
  }

  requestAnimationFrame(draw);
}

function gameLoop() {
  update();
  requestAnimationFrame(gameLoop);
}

gameLoop();
draw();
</script>
</body>
</html>
