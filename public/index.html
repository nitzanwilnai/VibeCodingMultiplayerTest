<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multiplayer Circles</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0f;
    color: #e0e0e0;
    font-family: 'JetBrains Mono', monospace;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  #topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    background: rgba(255,255,255,0.03);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    z-index: 10;
  }

  #topbar h1 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #888;
  }

  #topbar h1 span { color: #4ECDC4; }

  .status-area {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  #player-count {
    font-size: 12px;
    color: #666;
  }

  #player-count span {
    color: #4ECDC4;
    font-weight: 700;
  }

  #name-input {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: #fff;
    padding: 6px 12px;
    border-radius: 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    outline: none;
    width: 160px;
    transition: border-color 0.2s;
  }

  #name-input:focus {
    border-color: #4ECDC4;
  }

  #connection-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #555;
    transition: background 0.3s;
  }

  #connection-dot.connected { background: #4ECDC4; box-shadow: 0 0 8px #4ECDC4; }
  #connection-dot.disconnected { background: #FF6B6B; box-shadow: 0 0 8px #FF6B6B; }

  #game-canvas {
    flex: 1;
    display: block;
    cursor: none;
  }

  #instructions {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 11px;
    color: #444;
    letter-spacing: 1px;
    text-transform: uppercase;
    pointer-events: none;
    transition: opacity 1s;
  }
</style>
</head>
<body>

<div id="topbar">
  <h1><span>●</span> MULTIPLAYER CIRCLES</h1>
  <div class="status-area">
    <span id="player-count"><span>0</span> online</span>
    <input id="name-input" type="text" placeholder="Your name..." maxlength="20" />
    <div id="connection-dot"></div>
  </div>
</div>

<canvas id="game-canvas"></canvas>
<div id="instructions">WASD or Arrow Keys to move</div>

<script>
// ── Config ──────────────────────────────────────────────────
const PLAYER_RADIUS = 22;
const SPEED = 5;
const LERP_FACTOR = 0.15;

// ── State ───────────────────────────────────────────────────
let myId = null;
let players = {};       // id -> { x, y, color, name }
let targets = {};       // id -> { x, y } (for interpolation)
let keys = {};
let ws = null;
let connected = false;

// ── Canvas Setup ────────────────────────────────────────────
const canvas = document.getElementById("game-canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - document.getElementById("topbar").offsetHeight;
}
window.addEventListener("resize", resize);
resize();

// ── WebSocket ───────────────────────────────────────────────
function connect() {
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  ws = new WebSocket(`${protocol}//${location.host}`);

  ws.onopen = () => {
    connected = true;
    document.getElementById("connection-dot").className = "connected";
  };

  ws.onclose = () => {
    connected = false;
    document.getElementById("connection-dot").className = "disconnected";
    myId = null;
    players = {};
    targets = {};
    // Reconnect after 2s
    setTimeout(connect, 2000);
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);

    switch (msg.type) {
      case "init":
        myId = msg.id;
        players = msg.players;
        // Set initial targets
        for (const [id, p] of Object.entries(players)) {
          targets[id] = { x: p.x, y: p.y };
        }
        document.getElementById("name-input").value = players[myId]?.name || "";
        updatePlayerCount();
        break;

      case "player_joined":
        players[msg.id] = msg.player;
        targets[msg.id] = { x: msg.player.x, y: msg.player.y };
        updatePlayerCount();
        break;

      case "player_moved":
        if (players[msg.id]) {
          targets[msg.id] = { x: msg.x, y: msg.y };
        }
        break;

      case "player_renamed":
        if (players[msg.id]) {
          players[msg.id].name = msg.name;
        }
        break;

      case "player_left":
        delete players[msg.id];
        delete targets[msg.id];
        updatePlayerCount();
        break;
    }
  };
}

connect();

function updatePlayerCount() {
  const count = Object.keys(players).length;
  document.getElementById("player-count").innerHTML = `<span>${count}</span> online`;
}

// ── Input ───────────────────────────────────────────────────
window.addEventListener("keydown", (e) => {
  keys[e.key] = true;
  // Hide instructions after first keypress
  document.getElementById("instructions").style.opacity = "0";
});
window.addEventListener("keyup", (e) => { keys[e.key] = false; });

// Name input
const nameInput = document.getElementById("name-input");
nameInput.addEventListener("keydown", (e) => { e.stopPropagation(); });
nameInput.addEventListener("keyup", (e) => { e.stopPropagation(); });
nameInput.addEventListener("change", () => {
  if (ws && ws.readyState === WebSocket.OPEN && nameInput.value.trim()) {
    ws.send(JSON.stringify({ type: "set_name", name: nameInput.value.trim() }));
  }
});

// ── Game Loop ───────────────────────────────────────────────
let lastSentX = 0, lastSentY = 0;

function update() {
  if (!myId || !players[myId]) return;

  const me = players[myId];
  let dx = 0, dy = 0;

  if (keys["w"] || keys["W"] || keys["ArrowUp"]) dy -= 1;
  if (keys["s"] || keys["S"] || keys["ArrowDown"]) dy += 1;
  if (keys["a"] || keys["A"] || keys["ArrowLeft"]) dx -= 1;
  if (keys["d"] || keys["D"] || keys["ArrowRight"]) dx += 1;

  // Normalize diagonal
  if (dx !== 0 && dy !== 0) {
    dx *= 0.707;
    dy *= 0.707;
  }

  me.x += dx * SPEED;
  me.y += dy * SPEED;

  // Clamp to canvas
  me.x = Math.max(PLAYER_RADIUS, Math.min(canvas.width - PLAYER_RADIUS, me.x));
  me.y = Math.max(PLAYER_RADIUS, Math.min(canvas.height - PLAYER_RADIUS, me.y));

  targets[myId] = { x: me.x, y: me.y };

  // Send position if moved
  if (ws && ws.readyState === WebSocket.OPEN) {
    if (Math.abs(me.x - lastSentX) > 0.5 || Math.abs(me.y - lastSentY) > 0.5) {
      ws.send(JSON.stringify({ type: "move", x: me.x, y: me.y }));
      lastSentX = me.x;
      lastSentY = me.y;
    }
  }

  // Interpolate other players
  for (const [id, p] of Object.entries(players)) {
    if (String(id) === String(myId)) continue;
    const t = targets[id];
    if (t) {
      p.x += (t.x - p.x) * LERP_FACTOR;
      p.y += (t.y - p.y) * LERP_FACTOR;
    }
  }
}

// ── Rendering ───────────────────────────────────────────────
function drawGrid() {
  ctx.strokeStyle = "rgba(255,255,255,0.025)";
  ctx.lineWidth = 1;
  const step = 50;
  for (let x = 0; x < canvas.width; x += step) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += step) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
}

function drawPlayer(p, id) {
  const isMe = String(id) === String(myId);
  const r = PLAYER_RADIUS;

  // Outer glow
  const glow = ctx.createRadialGradient(p.x, p.y, r * 0.5, p.x, p.y, r * 2.5);
  glow.addColorStop(0, p.color + "30");
  glow.addColorStop(1, "transparent");
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(p.x, p.y, r * 2.5, 0, Math.PI * 2);
  ctx.fill();

  // Main circle
  ctx.fillStyle = p.color;
  ctx.shadowColor = p.color;
  ctx.shadowBlur = isMe ? 20 : 10;
  ctx.beginPath();
  ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Inner highlight
  const highlight = ctx.createRadialGradient(p.x - r * 0.3, p.y - r * 0.3, 0, p.x, p.y, r);
  highlight.addColorStop(0, "rgba(255,255,255,0.25)");
  highlight.addColorStop(1, "transparent");
  ctx.fillStyle = highlight;
  ctx.beginPath();
  ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
  ctx.fill();

  // Ring for self
  if (isMe) {
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r + 6, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Name tag
  ctx.fillStyle = "#fff";
  ctx.font = "bold 11px 'JetBrains Mono', monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  const label = isMe ? `${p.name} (you)` : p.name;
  ctx.fillText(label, p.x, p.y + r + 10);
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();

  // Draw other players first, then self on top
  for (const [id, p] of Object.entries(players)) {
    if (String(id) !== String(myId)) drawPlayer(p, id);
  }
  if (myId && players[myId]) {
    drawPlayer(players[myId], myId);
  }

  // If disconnected, show overlay
  if (!connected) {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#FF6B6B";
    ctx.font = "bold 18px 'JetBrains Mono', monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("RECONNECTING...", canvas.width / 2, canvas.height / 2);
  }
}

// ── Main Loop ───────────────────────────────────────────────
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
