<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Dark Room — Multiplayer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    cursor: none;
    font-family: 'Courier New', monospace;
  }
  canvas { display: block; }

  #overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    transition: opacity 1.5s ease;
  }
  #overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #overlay h1 {
    color: #8b0000;
    font-size: 3rem;
    letter-spacing: 0.5em;
    text-transform: uppercase;
    animation: flicker 3s infinite;
    margin-bottom: 1rem;
  }
  #overlay p {
    color: #555;
    font-size: 0.9rem;
    letter-spacing: 0.2em;
  }
  #overlay .name-row {
    margin-top: 1.5rem;
    display: flex;
    gap: 10px;
    align-items: center;
  }
  #overlay .name-row input {
    background: rgba(255,255,255,0.05);
    border: 1px solid #8b0000;
    color: #ccc;
    padding: 10px 16px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    letter-spacing: 0.1em;
    outline: none;
    width: 200px;
  }
  #overlay .name-row input:focus {
    border-color: #c0392b;
  }
  #overlay .start-btn {
    margin-top: 1.5rem;
    padding: 12px 40px;
    background: none;
    border: 1px solid #8b0000;
    color: #8b0000;
    font-family: 'Courier New', monospace;
    font-size: 1rem;
    letter-spacing: 0.3em;
    cursor: pointer;
    transition: all 0.3s;
  }
  #overlay .start-btn:hover {
    background: #8b0000;
    color: #000;
  }
  @keyframes flicker {
    0%, 100% { opacity: 1; }
    41% { opacity: 1; }
    42% { opacity: 0.3; }
    43% { opacity: 1; }
    77% { opacity: 1; }
    78% { opacity: 0.6; }
    79% { opacity: 1; }
  }

  #hud {
    position: fixed;
    top: 16px;
    right: 20px;
    color: #444;
    font-size: 0.7rem;
    letter-spacing: 0.15em;
    z-index: 5;
    pointer-events: none;
    text-align: right;
    line-height: 1.8;
  }
  #hud .online { color: #8b0000; }

  #connection-indicator {
    position: fixed;
    top: 16px;
    left: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 5;
    pointer-events: none;
  }
  #connection-indicator .dot {
    width: 6px; height: 6px;
    border-radius: 50%;
    background: #333;
    transition: all 0.3s;
  }
  #connection-indicator .dot.on {
    background: #4a1a1a;
    box-shadow: 0 0 6px #8b0000;
  }
  #connection-indicator .dot.off {
    background: #8b0000;
    animation: pulse-dot 1.5s infinite;
  }
  @keyframes pulse-dot {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 1; }
  }
  #connection-indicator .label {
    color: #333;
    font-size: 0.6rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
  }
</style>
</head>
<body>

<div id="overlay">
  <h1>The Dark Room</h1>
  <p>WASD to move · Mouse to aim flashlight</p>
  <p style="margin-top: 0.5rem; color: #444;">Multiplayer — explore together</p>
  <div class="name-row">
    <input type="text" id="nameInput" placeholder="Enter your name..." maxlength="20" />
  </div>
  <button class="start-btn" id="startBtn">ENTER THE DARK</button>
</div>

<canvas id="game"></canvas>

<div id="connection-indicator">
  <div class="dot" id="connDot"></div>
  <span class="label" id="connLabel">connecting</span>
</div>

<div id="hud">
  <span class="online" id="onlineCount">0</span> ONLINE
</div>

<script>
// ═══════════════════════════════════════════════════════════
//  CONFIG
// ═══════════════════════════════════════════════════════════
const ROOM_SIZE = 800;
const WALL_THICKNESS = 16;
const PLAYER_RADIUS = 10;
const FLASHLIGHT_RANGE = 280;
const FLASHLIGHT_ANGLE = Math.PI / 5.5;
const LERP_FACTOR = 0.15;
const ANGLE_LERP = 0.12;
const SPEED = 2.2;

// ═══════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════
let myId = null;
let localPlayer = { x: 400, y: 400, angle: 0 };
let remotePlayers = {};   // id -> { x, y, angle, color, name, tx, ty, tAngle }
let keys = {};
let mouseX = 0, mouseY = 0;
let started = false;
let time = 0;
let ws = null;
let connected = false;

// Canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ═══════════════════════════════════════════════════════════
//  ROOM OBJECTS
// ═══════════════════════════════════════════════════════════
const columns = [
  { x: 250, y: 250, r: 28 },
  { x: 550, y: 250, r: 28 },
  { x: 250, y: 550, r: 28 },
  { x: 550, y: 550, r: 28 },
];

const pedestal = { x: 400, y: 400, size: 36 };

// Dust particles
const particles = [];
for (let i = 0; i < 80; i++) {
  particles.push({
    x: Math.random() * ROOM_SIZE,
    y: Math.random() * ROOM_SIZE,
    vx: (Math.random() - 0.5) * 0.3,
    vy: (Math.random() - 0.5) * 0.3,
    size: Math.random() * 2 + 0.5,
    alpha: Math.random() * 0.5 + 0.1,
  });
}

// ═══════════════════════════════════════════════════════════
//  WEBSOCKET
// ═══════════════════════════════════════════════════════════
function wsConnect() {
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  ws = new WebSocket(`${protocol}//${location.host}`);

  ws.onopen = () => {
    connected = true;
    document.getElementById('connDot').className = 'dot on';
    document.getElementById('connLabel').textContent = 'connected';
  };

  ws.onclose = () => {
    connected = false;
    myId = null;
    remotePlayers = {};
    document.getElementById('connDot').className = 'dot off';
    document.getElementById('connLabel').textContent = 'reconnecting';
    setTimeout(wsConnect, 2000);
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    switch (msg.type) {
      case "init": {
        myId = msg.id;
        const all = msg.players;
        // Set our position from server
        if (all[myId]) {
          localPlayer.x = all[myId].x;
          localPlayer.y = all[myId].y;
          localPlayer.angle = all[myId].angle;
        }
        // All others become remote
        for (const [id, p] of Object.entries(all)) {
          if (Number(id) === myId) continue;
          remotePlayers[id] = {
            x: p.x, y: p.y, angle: p.angle,
            tx: p.x, ty: p.y, tAngle: p.angle,
            color: p.color, name: p.name,
          };
        }
        // Send our name if set
        const nameVal = document.getElementById('nameInput').value.trim();
        if (nameVal && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "set_name", name: nameVal }));
        }
        updateOnlineCount();
        break;
      }
      case "player_joined": {
        const p = msg.player;
        remotePlayers[msg.id] = {
          x: p.x, y: p.y, angle: p.angle,
          tx: p.x, ty: p.y, tAngle: p.angle,
          color: p.color, name: p.name,
        };
        updateOnlineCount();
        break;
      }
      case "player_moved": {
        const rp = remotePlayers[msg.id];
        if (rp) {
          rp.tx = msg.x;
          rp.ty = msg.y;
          rp.tAngle = msg.angle;
        }
        break;
      }
      case "player_renamed": {
        const rp = remotePlayers[msg.id];
        if (rp) rp.name = msg.name;
        break;
      }
      case "player_left": {
        delete remotePlayers[msg.id];
        updateOnlineCount();
        break;
      }
    }
  };
}
wsConnect();

function updateOnlineCount() {
  document.getElementById('onlineCount').textContent = Object.keys(remotePlayers).length + (myId ? 1 : 0);
}

// ═══════════════════════════════════════════════════════════
//  INPUT
// ═══════════════════════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  if (document.getElementById('overlay').classList.contains('hidden') || e.target.tagName !== 'INPUT') {
    keys[e.key.toLowerCase()] = true;
  }
});
document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  if (document.pointerLockElement === canvas) {
    localPlayer.angle += e.movementX * 0.003;
  }
});

canvas.addEventListener('click', () => {
  if (started) canvas.requestPointerLock?.();
});

document.getElementById('startBtn').addEventListener('click', () => {
  started = true;
  document.getElementById('overlay').classList.add('hidden');
  // Send name
  const name = document.getElementById('nameInput').value.trim();
  if (name && ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "set_name", name }));
  }
  canvas.requestPointerLock?.();
});

// Allow Enter in name input to start
document.getElementById('nameInput').addEventListener('keydown', (e) => {
  e.stopPropagation();
  if (e.key === 'Enter') document.getElementById('startBtn').click();
});

// ═══════════════════════════════════════════════════════════
//  COLLISION
// ═══════════════════════════════════════════════════════════
function circleCollides(px, py, pr, cx, cy, cr) {
  const dx = px - cx, dy = py - cy;
  return Math.sqrt(dx * dx + dy * dy) < pr + cr;
}

function tryMove(nx, ny) {
  const margin = PLAYER_RADIUS + WALL_THICKNESS;
  nx = Math.max(margin, Math.min(ROOM_SIZE - margin, nx));
  ny = Math.max(margin, Math.min(ROOM_SIZE - margin, ny));

  for (const col of columns) {
    if (circleCollides(nx, ny, PLAYER_RADIUS, col.x, col.y, col.r)) {
      const dx = nx - col.x, dy = ny - col.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const push = (PLAYER_RADIUS + col.r) / dist;
      nx = col.x + dx * push;
      ny = col.y + dy * push;
    }
  }

  const ps = pedestal.size / 2 + PLAYER_RADIUS;
  if (nx > pedestal.x - ps && nx < pedestal.x + ps &&
      ny > pedestal.y - ps && ny < pedestal.y + ps) {
    const dx = nx - pedestal.x, dy = ny - pedestal.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      nx = pedestal.x + Math.sign(dx) * ps;
    } else {
      ny = pedestal.y + Math.sign(dy) * ps;
    }
  }

  localPlayer.x = nx;
  localPlayer.y = ny;
}

// ═══════════════════════════════════════════════════════════
//  FLASHLIGHT HELPERS
// ═══════════════════════════════════════════════════════════
function isInFlashlight(wx, wy, px, py, pAngle) {
  const dx = wx - px, dy = wy - py;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > FLASHLIGHT_RANGE) return 0;
  const angleToPoint = Math.atan2(dy, dx);
  let angleDiff = angleToPoint - pAngle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  if (Math.abs(angleDiff) > FLASHLIGHT_ANGLE) return 0;
  return (1 - dist / FLASHLIGHT_RANGE) * (1 - Math.abs(angleDiff) / FLASHLIGHT_ANGLE);
}

function castRay(ox, oy, angle, maxDist) {
  const step = 3;
  for (let d = 0; d < maxDist; d += step) {
    const x = ox + Math.cos(angle) * d;
    const y = oy + Math.sin(angle) * d;
    if (x <= WALL_THICKNESS || x >= ROOM_SIZE - WALL_THICKNESS ||
        y <= WALL_THICKNESS || y >= ROOM_SIZE - WALL_THICKNESS) return d;
    for (const col of columns) {
      const dx = x - col.x, dy = y - col.y;
      if (dx * dx + dy * dy < col.r * col.r) return d;
    }
    const hs = pedestal.size / 2;
    if (x > pedestal.x - hs && x < pedestal.x + hs &&
        y > pedestal.y - hs && y < pedestal.y + hs) return d;
  }
  return maxDist;
}

function buildLightPoly(px, py, pAngle) {
  const numRays = 80;
  const startA = pAngle - FLASHLIGHT_ANGLE;
  const endA = pAngle + FLASHLIGHT_ANGLE;
  const step = (endA - startA) / numRays;
  const poly = [{ x: px, y: py }];
  for (let i = 0; i <= numRays; i++) {
    const a = startA + step * i;
    const dist = castRay(px, py, a, FLASHLIGHT_RANGE);
    poly.push({ x: px + Math.cos(a) * dist, y: py + Math.sin(a) * dist });
  }
  return poly;
}

// ═══════════════════════════════════════════════════════════
//  UPDATE
// ═══════════════════════════════════════════════════════════
let lastSentX = 0, lastSentY = 0, lastSentAngle = 0;

function update() {
  if (!started) return;
  time += 0.016;

  // Local movement
  const cos = Math.cos(localPlayer.angle);
  const sin = Math.sin(localPlayer.angle);
  let dx = 0, dy = 0;
  if (keys['w']) { dx += cos * SPEED; dy += sin * SPEED; }
  if (keys['s']) { dx -= cos * SPEED; dy -= sin * SPEED; }
  if (keys['a']) { dx += sin * SPEED; dy -= cos * SPEED; }
  if (keys['d']) { dx -= sin * SPEED; dy += cos * SPEED; }
  if (dx !== 0 || dy !== 0) tryMove(localPlayer.x + dx, localPlayer.y + dy);

  // Mouse aim (when no pointer lock)
  if (document.pointerLockElement !== canvas) {
    const cx = canvas.width / 2, cy = canvas.height / 2;
    localPlayer.angle = Math.atan2(mouseY - cy, mouseX - cx);
  }

  // Send position
  if (ws && ws.readyState === WebSocket.OPEN) {
    const moved = Math.abs(localPlayer.x - lastSentX) > 0.5 ||
                  Math.abs(localPlayer.y - lastSentY) > 0.5 ||
                  Math.abs(localPlayer.angle - lastSentAngle) > 0.02;
    if (moved) {
      ws.send(JSON.stringify({ type: "move", x: localPlayer.x, y: localPlayer.y, angle: localPlayer.angle }));
      lastSentX = localPlayer.x;
      lastSentY = localPlayer.y;
      lastSentAngle = localPlayer.angle;
    }
  }

  // Interpolate remote players
  for (const rp of Object.values(remotePlayers)) {
    rp.x += (rp.tx - rp.x) * LERP_FACTOR;
    rp.y += (rp.ty - rp.y) * LERP_FACTOR;
    // Angle lerp (handle wrapping)
    let da = rp.tAngle - rp.angle;
    while (da > Math.PI) da -= Math.PI * 2;
    while (da < -Math.PI) da += Math.PI * 2;
    rp.angle += da * ANGLE_LERP;
  }

  // Particles
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) p.x = ROOM_SIZE;
    if (p.x > ROOM_SIZE) p.x = 0;
    if (p.y < 0) p.y = ROOM_SIZE;
    if (p.y > ROOM_SIZE) p.y = 0;
  }
}

// ═══════════════════════════════════════════════════════════
//  DRAW
// ═══════════════════════════════════════════════════════════
function drawFlashlightPass(px, py, pAngle, tintColor, intensity) {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const offsetX = cx - localPlayer.x;
  const offsetY = cy - localPlayer.y;
  const lightPoly = buildLightPoly(px, py, pAngle);
  const flicker = 0.95 + Math.sin(time * 8 + px) * 0.03 + Math.sin(time * 13 + py) * 0.02;

  ctx.save();
  ctx.translate(offsetX, offsetY);

  // Clip to light cone
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(lightPoly[0].x, lightPoly[0].y);
  for (let i = 1; i < lightPoly.length; i++) ctx.lineTo(lightPoly[i].x, lightPoly[i].y);
  ctx.closePath();
  ctx.clip();

  // Radial light gradient
  const grad = ctx.createRadialGradient(px, py, 0, px, py, FLASHLIGHT_RANGE);
  if (tintColor) {
    // Remote players get a subtle colored tint
    const r = parseInt(tintColor.slice(1,3),16);
    const g = parseInt(tintColor.slice(3,5),16);
    const b = parseInt(tintColor.slice(5,7),16);
    grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.25 * flicker * intensity})`);
    grad.addColorStop(0.3, `rgba(${Math.floor(r*0.8)}, ${Math.floor(g*0.8)}, ${Math.floor(b*0.7)}, ${0.15 * flicker * intensity})`);
    grad.addColorStop(0.7, `rgba(${Math.floor(r*0.5)}, ${Math.floor(g*0.5)}, ${Math.floor(b*0.4)}, ${0.05 * flicker * intensity})`);
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  } else {
    // Local player: warm white
    grad.addColorStop(0, `rgba(255, 240, 200, ${0.35 * flicker})`);
    grad.addColorStop(0.3, `rgba(255, 220, 160, ${0.2 * flicker})`);
    grad.addColorStop(0.7, `rgba(200, 170, 120, ${0.08 * flicker})`);
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, ROOM_SIZE, ROOM_SIZE);

  // Floor tiles
  ctx.strokeStyle = 'rgba(80, 70, 55, 0.15)';
  ctx.lineWidth = 0.5;
  const tileSize = 40;
  for (let tx = 0; tx < ROOM_SIZE; tx += tileSize) {
    for (let ty = 0; ty < ROOM_SIZE; ty += tileSize) {
      const i = isInFlashlight(tx + tileSize/2, ty + tileSize/2, px, py, pAngle);
      if (i > 0.01) {
        ctx.globalAlpha = i * 0.6 * intensity;
        ctx.strokeRect(tx, ty, tileSize, tileSize);
      }
    }
  }
  ctx.globalAlpha = 1;

  // Walls
  ctx.fillStyle = '#3a3028';
  ctx.fillRect(0, 0, ROOM_SIZE, WALL_THICKNESS);
  ctx.fillRect(0, ROOM_SIZE - WALL_THICKNESS, ROOM_SIZE, WALL_THICKNESS);
  ctx.fillRect(0, 0, WALL_THICKNESS, ROOM_SIZE);
  ctx.fillRect(ROOM_SIZE - WALL_THICKNESS, 0, WALL_THICKNESS, ROOM_SIZE);

  ctx.strokeStyle = 'rgba(100, 85, 65, 0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(WALL_THICKNESS, WALL_THICKNESS, ROOM_SIZE - WALL_THICKNESS*2, ROOM_SIZE - WALL_THICKNESS*2);

  // Columns
  for (const col of columns) {
    const ci = isInFlashlight(col.x, col.y, px, py, pAngle);
    if (ci > 0.01) {
      ctx.fillStyle = `rgba(20, 15, 10, ${ci * 0.5})`;
      ctx.beginPath();
      ctx.ellipse(col.x + 3, col.y + 3, col.r + 4, col.r + 4, 0, 0, Math.PI * 2);
      ctx.fill();

      const cGrad = ctx.createRadialGradient(col.x - col.r*0.3, col.y - col.r*0.3, 0, col.x, col.y, col.r);
      cGrad.addColorStop(0, `rgba(120, 105, 85, ${ci})`);
      cGrad.addColorStop(0.6, `rgba(80, 70, 55, ${ci})`);
      cGrad.addColorStop(1, `rgba(40, 35, 28, ${ci})`);
      ctx.fillStyle = cGrad;
      ctx.beginPath();
      ctx.arc(col.x, col.y, col.r, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = `rgba(150, 130, 100, ${ci * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(col.x, col.y, col.r, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Pedestal
  const pedI = isInFlashlight(pedestal.x, pedestal.y, px, py, pAngle);
  if (pedI > 0.01) {
    const hs = pedestal.size / 2;
    ctx.fillStyle = `rgba(20, 15, 10, ${pedI * 0.4})`;
    ctx.fillRect(pedestal.x - hs + 3, pedestal.y - hs + 3, pedestal.size, pedestal.size);

    const pGrad = ctx.createLinearGradient(pedestal.x - hs, pedestal.y - hs, pedestal.x + hs, pedestal.y + hs);
    pGrad.addColorStop(0, `rgba(100, 85, 70, ${pedI})`);
    pGrad.addColorStop(0.5, `rgba(70, 60, 48, ${pedI})`);
    pGrad.addColorStop(1, `rgba(50, 42, 35, ${pedI})`);
    ctx.fillStyle = pGrad;
    ctx.fillRect(pedestal.x - hs, pedestal.y - hs, pedestal.size, pedestal.size);

    ctx.strokeStyle = `rgba(180, 150, 100, ${pedI * 0.5})`;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(pedestal.x - hs + 4, pedestal.y - hs + 4, pedestal.size - 8, pedestal.size - 8);

    const glowPulse = 0.3 + Math.sin(time * 2) * 0.15;
    const glowGrad = ctx.createRadialGradient(pedestal.x, pedestal.y, 0, pedestal.x, pedestal.y, hs * 1.5);
    glowGrad.addColorStop(0, `rgba(180, 50, 50, ${glowPulse * pedI})`);
    glowGrad.addColorStop(1, 'rgba(180, 50, 50, 0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(pedestal.x - hs*2, pedestal.y - hs*2, pedestal.size*2, pedestal.size*2);
  }

  // Dust particles in this light
  for (const p of particles) {
    const pi = isInFlashlight(p.x, p.y, px, py, pAngle);
    if (pi > 0.05) {
      ctx.fillStyle = `rgba(255, 240, 200, ${pi * p.alpha * 0.6 * intensity})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore(); // end clip
  ctx.restore(); // end world transform
}

function drawShadows(px, py, pAngle) {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const offsetX = cx - localPlayer.x;
  const offsetY = cy - localPlayer.y;

  ctx.save();
  ctx.translate(offsetX, offsetY);
  for (const col of columns) {
    const dx = col.x - px, dy = col.y - py;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < FLASHLIGHT_RANGE && isInFlashlight(col.x, col.y, px, py, pAngle) > 0) {
      const angle = Math.atan2(dy, dx);
      const perpAngle = angle + Math.PI / 2;
      const shadowLen = Math.min(200, FLASHLIGHT_RANGE - dist + 50);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
      ctx.beginPath();
      ctx.moveTo(col.x + Math.cos(perpAngle) * col.r, col.y + Math.sin(perpAngle) * col.r);
      ctx.lineTo(col.x - Math.cos(perpAngle) * col.r, col.y - Math.sin(perpAngle) * col.r);
      ctx.lineTo(col.x - Math.cos(perpAngle) * (col.r+10) + Math.cos(angle) * shadowLen,
                 col.y - Math.sin(perpAngle) * (col.r+10) + Math.sin(angle) * shadowLen);
      ctx.lineTo(col.x + Math.cos(perpAngle) * (col.r+10) + Math.cos(angle) * shadowLen,
                 col.y + Math.sin(perpAngle) * (col.r+10) + Math.sin(angle) * shadowLen);
      ctx.closePath();
      ctx.fill();
    }
  }
  ctx.restore();
}

function drawCharacter(px, py, pAngle, color, name, isLocal) {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const screenX = cx + (px - localPlayer.x);
  const screenY = cy + (py - localPlayer.y);

  // Check if any flashlight (ours or remote) illuminates this character
  let totalLight = isInFlashlight(px, py, localPlayer.x, localPlayer.y, localPlayer.angle);
  for (const rp of Object.values(remotePlayers)) {
    totalLight = Math.max(totalLight, isInFlashlight(px, py, rp.x, rp.y, rp.angle));
  }
  // The local player always sees themselves dimly
  if (isLocal) totalLight = Math.max(totalLight, 0.3);
  if (totalLight < 0.02) return; // invisible in the dark

  const flicker = 0.95 + Math.sin(time * 8 + px) * 0.03;

  ctx.save();
  ctx.translate(screenX, screenY);
  ctx.rotate(pAngle + Math.PI / 2);
  ctx.globalAlpha = Math.min(1, totalLight + 0.1);

  // Ambient glow
  const playerGlow = ctx.createRadialGradient(0, 0, 4, 0, 0, 28);
  playerGlow.addColorStop(0, `rgba(180, 160, 130, 0.15)`);
  playerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = playerGlow;
  ctx.beginPath();
  ctx.arc(0, 0, 28, 0, Math.PI * 2);
  ctx.fill();

  // Body
  const bodyGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, PLAYER_RADIUS);
  if (isLocal) {
    bodyGrad.addColorStop(0, '#8a7b6b');
    bodyGrad.addColorStop(0.7, '#5c5045');
    bodyGrad.addColorStop(1, '#3a332c');
  } else {
    // Tint with player color
    const r = parseInt(color.slice(1,3),16);
    const g = parseInt(color.slice(3,5),16);
    const b = parseInt(color.slice(5,7),16);
    bodyGrad.addColorStop(0, `rgb(${Math.floor(r*0.7)}, ${Math.floor(g*0.7)}, ${Math.floor(b*0.7)})`);
    bodyGrad.addColorStop(0.7, `rgb(${Math.floor(r*0.4)}, ${Math.floor(g*0.4)}, ${Math.floor(b*0.4)})`);
    bodyGrad.addColorStop(1, `rgb(${Math.floor(r*0.2)}, ${Math.floor(g*0.2)}, ${Math.floor(b*0.2)})`);
  }
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
  ctx.fill();

  // Body outline
  ctx.strokeStyle = isLocal ? 'rgba(200, 185, 155, 0.4)' : `${color}66`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
  ctx.stroke();

  // Head
  const headGrad = ctx.createRadialGradient(-1, -PLAYER_RADIUS-3, 0, 0, -PLAYER_RADIUS-3, 6);
  headGrad.addColorStop(0, '#c4a882');
  headGrad.addColorStop(1, '#7a6a58');
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(0, -PLAYER_RADIUS - 3, 6, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#e8dcc8';
  ctx.beginPath();
  ctx.arc(-2.2, -PLAYER_RADIUS - 5, 1.2, 0, Math.PI * 2);
  ctx.arc(2.2, -PLAYER_RADIUS - 5, 1.2, 0, Math.PI * 2);
  ctx.fill();

  // Flashlight in hand
  ctx.fillStyle = '#555';
  ctx.fillRect(5, -PLAYER_RADIUS - 8, 3, 8);
  const lensGlow = ctx.createRadialGradient(6.5, -PLAYER_RADIUS-9, 0, 6.5, -PLAYER_RADIUS-9, 5);
  const lensColor = isLocal ? `rgba(255, 240, 180, ${0.8 * flicker})` : `${color}cc`;
  lensGlow.addColorStop(0, lensColor);
  lensGlow.addColorStop(0.5, isLocal ? `rgba(255, 220, 140, ${0.3 * flicker})` : `${color}44`);
  lensGlow.addColorStop(1, 'rgba(255, 240, 180, 0)');
  ctx.fillStyle = lensGlow;
  ctx.beginPath();
  ctx.arc(6.5, -PLAYER_RADIUS - 9, 5, 0, Math.PI * 2);
  ctx.fill();

  ctx.globalAlpha = 1;
  ctx.restore();

  // Name label (unrotated, above character)
  if (name && totalLight > 0.1) {
    ctx.save();
    ctx.globalAlpha = Math.min(0.8, totalLight);
    ctx.fillStyle = isLocal ? '#aaa' : color;
    ctx.font = '10px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(name, screenX, screenY - PLAYER_RADIUS - 14);
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (!started) {
    requestAnimationFrame(draw);
    return;
  }

  // Draw all flashlight passes (light accumulates via lighter composite)
  ctx.globalCompositeOperation = 'lighter';

  // Local player flashlight
  drawFlashlightPass(localPlayer.x, localPlayer.y, localPlayer.angle, null, 1);

  // Remote player flashlights
  for (const rp of Object.values(remotePlayers)) {
    drawFlashlightPass(rp.x, rp.y, rp.angle, rp.color, 0.85);
  }

  ctx.globalCompositeOperation = 'source-over';

  // Shadows from local flashlight
  drawShadows(localPlayer.x, localPlayer.y, localPlayer.angle);
  // Shadows from remote flashlights
  for (const rp of Object.values(remotePlayers)) {
    drawShadows(rp.x, rp.y, rp.angle);
  }

  // Draw remote characters
  for (const rp of Object.values(remotePlayers)) {
    drawCharacter(rp.x, rp.y, rp.angle, rp.color, rp.name, false);
  }

  // Draw local character (always on top)
  drawCharacter(localPlayer.x, localPlayer.y, localPlayer.angle, '#8a7b6b', 'You', true);

  // Post-processing
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const vigGrad = ctx.createRadialGradient(cx, cy, canvas.width * 0.2, cx, cy, canvas.width * 0.7);
  vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Scanlines
  ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
  for (let y = 0; y < canvas.height; y += 3) {
    ctx.fillRect(0, y, canvas.width, 1);
  }

  // Disconnected overlay
  if (!connected) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#8b0000';
    ctx.font = 'bold 16px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('CONNECTION LOST — RECONNECTING...', canvas.width/2, canvas.height/2);
  }

  requestAnimationFrame(draw);
}

function gameLoop() {
  update();
  requestAnimationFrame(gameLoop);
}

gameLoop();
draw();
</script>
</body>
</html>
